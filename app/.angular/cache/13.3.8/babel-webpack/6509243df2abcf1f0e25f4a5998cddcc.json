{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, NgModule } from '@angular/core';\nimport { NetworkStatus, ApolloClient, gql as gql$1 } from '@apollo/client/core';\nimport { Observable, queueScheduler, observable, from } from 'rxjs';\nimport { map, startWith, observeOn } from 'rxjs/operators';\n\nfunction fromPromise(promiseFn) {\n  return new Observable(subscriber => {\n    promiseFn().then(result => {\n      if (!subscriber.closed) {\n        subscriber.next(result);\n        subscriber.complete();\n      }\n    }, error => {\n      if (!subscriber.closed) {\n        subscriber.error(error);\n      }\n    });\n    return () => subscriber.unsubscribe();\n  });\n}\n\nfunction useMutationLoading(source, enabled) {\n  if (!enabled) {\n    return source.pipe(map(result => Object.assign(Object.assign({}, result), {\n      loading: false\n    })));\n  }\n\n  return source.pipe(startWith({\n    loading: true\n  }), map(result => Object.assign(Object.assign({}, result), {\n    loading: !!result.loading\n  })));\n}\n\nclass ZoneScheduler {\n  constructor(zone) {\n    this.zone = zone;\n    this.now = Date.now ? Date.now : () => +new Date();\n  }\n\n  schedule(work, delay = 0, state) {\n    return this.zone.run(() => queueScheduler.schedule(work, delay, state));\n  }\n\n}\n\nfunction fixObservable(obs) {\n  obs[observable] = () => obs;\n\n  return obs;\n}\n\nfunction wrapWithZone(obs, ngZone) {\n  return obs.pipe(observeOn(new ZoneScheduler(ngZone)));\n}\n\nfunction pickFlag(flags, flag, defaultValue) {\n  return flags && typeof flags[flag] !== 'undefined' ? flags[flag] : defaultValue;\n}\n\nfunction useInitialLoading(obsQuery) {\n  return function useInitialLoadingOperator(source) {\n    return new Observable(function useInitialLoadingSubscription(subscriber) {\n      const currentResult = obsQuery.getCurrentResult();\n      const {\n        loading,\n        errors,\n        error,\n        partial,\n        data\n      } = currentResult;\n      const {\n        partialRefetch,\n        fetchPolicy\n      } = obsQuery.options;\n      const hasError = errors || error;\n\n      if (partialRefetch && partial && (!data || Object.keys(data).length === 0) && fetchPolicy !== 'cache-only' && !loading && !hasError) {\n        subscriber.next(Object.assign(Object.assign({}, currentResult), {\n          loading: true,\n          networkStatus: NetworkStatus.loading\n        }));\n      }\n\n      return source.subscribe(subscriber);\n    });\n  };\n}\n\nclass QueryRef {\n  constructor(obsQuery, ngZone, options) {\n    this.obsQuery = obsQuery;\n    const wrapped = wrapWithZone(from(fixObservable(this.obsQuery)), ngZone);\n    this.valueChanges = options.useInitialLoading ? wrapped.pipe(useInitialLoading(this.obsQuery)) : wrapped;\n    this.queryId = this.obsQuery.queryId;\n  } // ObservableQuery's methods\n\n\n  get options() {\n    return this.obsQuery.options;\n  }\n\n  get variables() {\n    return this.obsQuery.variables;\n  }\n\n  result() {\n    return this.obsQuery.result();\n  }\n\n  getCurrentResult() {\n    return this.obsQuery.getCurrentResult();\n  }\n\n  getLastResult() {\n    return this.obsQuery.getLastResult();\n  }\n\n  getLastError() {\n    return this.obsQuery.getLastError();\n  }\n\n  resetLastResults() {\n    return this.obsQuery.resetLastResults();\n  }\n\n  refetch(variables) {\n    return this.obsQuery.refetch(variables);\n  }\n\n  fetchMore(fetchMoreOptions) {\n    return this.obsQuery.fetchMore(fetchMoreOptions);\n  }\n\n  subscribeToMore(options) {\n    // XXX: there's a bug in apollo-client typings\n    // it should not inherit types from ObservableQuery\n    return this.obsQuery.subscribeToMore(options);\n  }\n\n  updateQuery(mapFn) {\n    return this.obsQuery.updateQuery(mapFn);\n  }\n\n  stopPolling() {\n    return this.obsQuery.stopPolling();\n  }\n\n  startPolling(pollInterval) {\n    return this.obsQuery.startPolling(pollInterval);\n  }\n\n  setOptions(opts) {\n    return this.obsQuery.setOptions(opts);\n  }\n\n  setVariables(variables) {\n    return this.obsQuery.setVariables(variables);\n  }\n\n}\n\nconst APOLLO_FLAGS = new InjectionToken('APOLLO_FLAGS');\nconst APOLLO_OPTIONS = new InjectionToken('APOLLO_OPTIONS');\nconst APOLLO_NAMED_OPTIONS = new InjectionToken('APOLLO_NAMED_OPTIONS');\n\nclass ApolloBase {\n  constructor(ngZone, flags, _client) {\n    this.ngZone = ngZone;\n    this.flags = flags;\n    this._client = _client;\n    this.useInitialLoading = pickFlag(flags, 'useInitialLoading', false);\n    this.useMutationLoading = pickFlag(flags, 'useMutationLoading', false);\n  }\n\n  watchQuery(options) {\n    return new QueryRef(this.ensureClient().watchQuery(Object.assign({}, options)), this.ngZone, Object.assign({\n      useInitialLoading: this.useInitialLoading\n    }, options));\n  }\n\n  query(options) {\n    return fromPromise(() => this.ensureClient().query(Object.assign({}, options)));\n  }\n\n  mutate(options) {\n    var _a;\n\n    return useMutationLoading(fromPromise(() => this.ensureClient().mutate(Object.assign({}, options))), (_a = options.useMutationLoading) !== null && _a !== void 0 ? _a : this.useMutationLoading);\n  }\n\n  subscribe(options, extra) {\n    const obs = from(fixObservable(this.ensureClient().subscribe(Object.assign({}, options))));\n    return extra && extra.useZone !== true ? obs : wrapWithZone(obs, this.ngZone);\n  }\n  /**\n   * Get an access to an instance of ApolloClient\n   * @deprecated use `apollo.client` instead\n   */\n\n\n  getClient() {\n    return this.client;\n  }\n  /**\n   * Set a new instance of ApolloClient\n   * Remember to clean up the store before setting a new client.\n   * @deprecated use `apollo.client = client` instead\n   *\n   * @param client ApolloClient instance\n   */\n\n\n  setClient(client) {\n    this.client = client;\n  }\n  /**\n   * Get an access to an instance of ApolloClient\n   */\n\n\n  get client() {\n    return this._client;\n  }\n  /**\n   * Set a new instance of ApolloClient\n   * Remember to clean up the store before setting a new client.\n   *\n   * @param client ApolloClient instance\n   */\n\n\n  set client(client) {\n    if (this._client) {\n      throw new Error('Client has been already defined');\n    }\n\n    this._client = client;\n  }\n\n  ensureClient() {\n    this.checkInstance();\n    return this._client;\n  }\n\n  checkInstance() {\n    if (!this._client) {\n      throw new Error('Client has not been defined yet');\n    }\n  }\n\n}\n\nlet Apollo = /*#__PURE__*/(() => {\n  class Apollo extends ApolloBase {\n    constructor(_ngZone, apolloOptions, apolloNamedOptions, flags) {\n      super(_ngZone, flags);\n      this._ngZone = _ngZone;\n      this.map = new Map();\n\n      if (apolloOptions) {\n        this.createDefault(apolloOptions);\n      }\n\n      if (apolloNamedOptions && typeof apolloNamedOptions === 'object') {\n        for (let name in apolloNamedOptions) {\n          if (apolloNamedOptions.hasOwnProperty(name)) {\n            const options = apolloNamedOptions[name];\n            this.createNamed(name, options);\n          }\n        }\n      }\n    }\n    /**\n     * Create an instance of ApolloClient\n     * @param options Options required to create ApolloClient\n     * @param name client's name\n     */\n\n\n    create(options, name) {\n      if (isDefault(name)) {\n        this.createDefault(options);\n      } else {\n        this.createNamed(name, options);\n      }\n    }\n    /**\n     * Use a default ApolloClient\n     */\n\n\n    default() {\n      return this;\n    }\n    /**\n     * Use a named ApolloClient\n     * @param name client's name\n     */\n\n\n    use(name) {\n      if (isDefault(name)) {\n        return this.default();\n      }\n\n      return this.map.get(name);\n    }\n    /**\n     * Create a default ApolloClient, same as `apollo.create(options)`\n     * @param options ApolloClient's options\n     */\n\n\n    createDefault(options) {\n      if (this.getClient()) {\n        throw new Error('Apollo has been already created.');\n      }\n\n      return this.setClient(new ApolloClient(options));\n    }\n    /**\n     * Create a named ApolloClient, same as `apollo.create(options, name)`\n     * @param name client's name\n     * @param options ApolloClient's options\n     */\n\n\n    createNamed(name, options) {\n      if (this.map.has(name)) {\n        throw new Error(`Client ${name} has been already created`);\n      }\n\n      this.map.set(name, new ApolloBase(this._ngZone, this.flags, new ApolloClient(options)));\n    }\n    /**\n     * Remember to clean up the store before removing a client\n     * @param name client's name\n     */\n\n\n    removeClient(name) {\n      if (isDefault(name)) {\n        this._client = undefined;\n      } else {\n        this.map.delete(name);\n      }\n    }\n\n  }\n\n  Apollo.ɵfac = function Apollo_Factory(t) {\n    return new (t || Apollo)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(APOLLO_OPTIONS, 8), i0.ɵɵinject(APOLLO_NAMED_OPTIONS, 8), i0.ɵɵinject(APOLLO_FLAGS, 8));\n  };\n\n  Apollo.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Apollo,\n    factory: Apollo.ɵfac\n  });\n  return Apollo;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction isDefault(name) {\n  return !name || name === 'default';\n}\n\nconst PROVIDERS = [Apollo];\nlet ApolloModule = /*#__PURE__*/(() => {\n  class ApolloModule {}\n\n  ApolloModule.ɵfac = function ApolloModule_Factory(t) {\n    return new (t || ApolloModule)();\n  };\n\n  ApolloModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ApolloModule\n  });\n  ApolloModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: PROVIDERS\n  });\n  return ApolloModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet Query = /*#__PURE__*/(() => {\n  class Query {\n    constructor(apollo) {\n      this.apollo = apollo;\n      this.client = 'default';\n    }\n\n    watch(variables, options) {\n      return this.apollo.use(this.client).watchQuery(Object.assign(Object.assign({}, options), {\n        variables,\n        query: this.document\n      }));\n    }\n\n    fetch(variables, options) {\n      return this.apollo.use(this.client).query(Object.assign(Object.assign({}, options), {\n        variables,\n        query: this.document\n      }));\n    }\n\n  }\n\n  Query.ɵfac = function Query_Factory(t) {\n    return new (t || Query)(i0.ɵɵinject(Apollo));\n  };\n\n  Query.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Query,\n    factory: Query.ɵfac\n  });\n  return Query;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet Mutation = /*#__PURE__*/(() => {\n  class Mutation {\n    constructor(apollo) {\n      this.apollo = apollo;\n      this.client = 'default';\n    }\n\n    mutate(variables, options) {\n      return this.apollo.use(this.client).mutate(Object.assign(Object.assign({}, options), {\n        variables,\n        mutation: this.document\n      }));\n    }\n\n  }\n\n  Mutation.ɵfac = function Mutation_Factory(t) {\n    return new (t || Mutation)(i0.ɵɵinject(Apollo));\n  };\n\n  Mutation.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Mutation,\n    factory: Mutation.ɵfac\n  });\n  return Mutation;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet Subscription = /*#__PURE__*/(() => {\n  class Subscription {\n    constructor(apollo) {\n      this.apollo = apollo;\n      this.client = 'default';\n    }\n\n    subscribe(variables, options, extra) {\n      return this.apollo.use(this.client).subscribe(Object.assign(Object.assign({}, options), {\n        variables,\n        query: this.document\n      }), extra);\n    }\n\n  }\n\n  Subscription.ɵfac = function Subscription_Factory(t) {\n    return new (t || Subscription)(i0.ɵɵinject(Apollo));\n  };\n\n  Subscription.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Subscription,\n    factory: Subscription.ɵfac\n  });\n  return Subscription;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction typedGQLTag(literals, ...placeholders) {\n  return gql$1(literals, ...placeholders);\n}\n\nconst gql = typedGQLTag;\nconst graphql = typedGQLTag;\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { APOLLO_FLAGS, APOLLO_NAMED_OPTIONS, APOLLO_OPTIONS, Apollo, ApolloBase, ApolloModule, Mutation, Query, QueryRef, Subscription, gql, graphql }; //# sourceMappingURL=ngApollo.mjs.map","map":null,"metadata":{},"sourceType":"module"}